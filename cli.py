#!/usr/bin/env python3

import json
from multiprocessing.sharedctypes import Value
import re
import subprocess
from datetime import datetime
from typing import List
from pathlib import Path
import typer
import shutil
import fileinput
import jinja2 as j2
from tqdm import tqdm


PROJECT = Path(__file__).parent

STATIC = PROJECT.joinpath("static")  # static files for the website
STATIC.mkdir(exist_ok=True)

WEB_ROOT = PROJECT.joinpath("public", "exercises")  # target folder for the website
WEB_ROOT.mkdir(exist_ok=True, parents=True)

SINGLE_EXERCISE = WEB_ROOT.joinpath("single_exercise")
SINGLE_EXERCISE.mkdir(exist_ok=True)

EXERCISES = PROJECT.joinpath("exercises")  # exercise tex files
TEMPLATES = PROJECT.joinpath("templates")

latex_jinja = j2.Environment(
    block_start_string="((*",
    block_end_string="*))",
    variable_start_string="((",
    variable_end_string="))",
    loader=j2.FileSystemLoader(TEMPLATES.resolve()),
    autoescape=False,
)
html_jinja = j2.Environment(
    loader=j2.FileSystemLoader(TEMPLATES.resolve()),
    autoescape=False,
)

app = typer.Typer(
    help="""
        Command Line Interface (CLI) for various management scripts. E.g.
        generating a website from the .tex files.
        """
)


def relative(target: Path, origin: Path) -> Path:
    """return path of target relative to origin"""
    try:
        return Path(target).resolve().relative_to(Path(origin).resolve())
    except ValueError as e:  # target does not start with origin
        # recursion with origin (eventually origin is root so try will succeed)
        return Path("..").joinpath(relative(target, Path(origin).parent))


def scrape_tutorial_date(file: Path) -> datetime:
    """
    Extract \\tutorialDate{<...>} from file and convert to datetime Date
    """
    with open(file, "r") as f:
        return datetime.strptime(
            # find \tutorialDate{<match_group>} where the match group may be
            # characters not including "}", last match counts
            re.findall(r"\\tutorialDate\{([^\}]*)\}", f.read())[-1],
            "%d.%m.%Y",  # TODO allow for more formats?
        )


def scrape_exercises(file: Path) -> List[Path]:
    """
    Extract all \\input{exercises/<...>} from file and returns list of paths
    """
    with open(file, "r") as f:
        return [
            Path(x)
            for x in re.findall(r"\n[^\%^\n]*\\input\{(exercises\/[^\}]*)\}", f.read())
        ]


def latexmlc_html_fragment(input):
    """returns html fragment of the latex document generated by latexmlc"""
    # fmt: off
    ps = subprocess.run([
            "latexmlc",
            "--whatsout", "fragment",
            "--format", "html5",
            "--nodefaultresources",
            "-"
        ],
        input=input,
        text=True,
        capture_output=True,
        cwd=PROJECT,
        check=True
    )
    # fmt: on
    if "Error" in ps.stderr:
        typer.echo(ps.stderr)
        typer.Exit(-1)

    with open("individual_exercise.log", "a") as f:
        f.write(ps.stderr)

    return ps.stdout


@app.command()
def html_individual_exercises(exercises: List[Path], use_cache: bool = True):
    """Turns the list of .tex exercises into html documents and saves them
    under the folder "single_exercise" in the website root

    returns the list of created files relative to the website root
    """
    available_exercises = []
    for exercise_file in (pg_bar := tqdm(exercises)):
        pg_bar.set_description(f"Processing: {str(exercise_file)}")

        destination = SINGLE_EXERCISE.joinpath(
            relative(exercise_file, EXERCISES).with_suffix(".html"),
        )
        tex_template = "single_exercise.tex.jinja2"
        html_template = "single_exercise.html.jinja2"

        # QUERY CACHE
        if (
            (not use_cache)
            or (not destination.exists())
            or files_changed_since(
                time=last_modified(destination),
                files=[
                    Path(exercise_file),
                    TEMPLATES.joinpath(tex_template),
                    TEMPLATES.joinpath(html_template),
                ],
            )
        ):  # THEN build
            destination.parent.mkdir(exist_ok=True)
            with open(destination, "w") as f:
                # make tex
                t = latex_jinja.get_template(tex_template)
                tex = t.render(exercise=str(relative(exercise_file, EXERCISES)))

                # convert to html
                exercise_body = latexmlc_html_fragment(tex)

                # insert html into template
                t = html_jinja.get_template(html_template)
                html_doc = t.render(
                    title=exercise_file.stem.capitalize().replace("_", " "),
                    article=exercise_body,
                )

                # write result into destination
                f.write(html_doc)

        available_exercises.append(relative(destination, WEB_ROOT))
    pg_bar.set_description(f"Done!")
    return available_exercises


@app.command()
def make_html(
    file: Path,
    source: Path = typer.Option(PROJECT, help="the directory of the tex-file"),
    destination: Path = typer.Option(
        WEB_ROOT, help="the target directory for the html file"
    ),
):
    """
    Turns the tex file into html
    """
    file_name = Path(file).stem  # allows either file_name.tex or just file_name

    tex_path = source.joinpath(file_name + ".tex")
    xml_path = source.joinpath("xml", file_name + ".xml")
    html_path = destination.joinpath(file_name + ".html")

    # fmt: off
    # make xml
    subprocess.run([
            "latexml",
            f"--dest", xml_path.absolute(),
            tex_path.absolute(),
        ],
        check=True,
        cwd=source,
    )

    # make html
    subprocess.run([
            "latexmlpost",
            "--dest", html_path.absolute(),
            "--xsltparameter", "LATEJS:true",
            "--nodefaultresources",
            "--javascript", "js/LaTeXML-maybeMathjax.js",
            "--javascript", "js/collapsing_proofs.js",
            "--css", "css/LaTeXML.css",
            "--css", "css/ltx-article.css",
            "--format", "html5",
            xml_path.absolute(),
        ],
        check=True,
        cwd=destination,
    )
    # fmt: on


def all_exercise_sheets():
    exercise_files = filter(
        lambda f: f.suffix == ".tex" and f.stem.startswith("sheet_"),
        PROJECT.iterdir(),
    )
    for ex_file in exercise_files:
        yield (int(re.search(r"sheet_([0-9]+).", str(ex_file)).groups()[0]), ex_file)


def last_modified(file: Path):
    """returns last modification time of file (may throw FileNotFoundError)"""
    return Path(file).stat().st_mtime


def files_changed_since(time, files: List[Path]):
    """returns true if any of the files changed since `time`

    time is passed to `git log --since`. So everything git is fine with, this
    function is fine with
    """
    files_relative = [str(relative(file, PROJECT)) for file in files]
    # fmt: off
    command = [
            "git", "log",
            "--max-count", "1",
            "--since", str(time), # git appears to accept unix timestamps
            "--"
    ]
    # fmt: on
    command.extend(files_relative)
    ps = subprocess.run(
        command, capture_output=True, text=True, cwd=PROJECT, check=True
    )
    return ps.stdout or set(files_relative).intersection(modified_files())


def modified_files():
    """return list of files modified since last commit"""
    ps = subprocess.run(
        [  # compare current state with one commit before HEAD
            "git",
            "diff",
            "--name-only",
            "HEAD",
        ],
        capture_output=True,
        text=True,
        check=True,
        cwd=PROJECT,
    )
    # no filter function means throw away falsy entries (i.e. empty strings)
    return list(filter(None, ps.stdout.split("\n")))


@app.command()
def solutions(show: bool = typer.Option(None, "--show/--hide")):
    """
    Set the Show/Hide-toggle for solutions in all the .tex files.
    """
    if show is None:
        typer.echo("Nothing selected, doing nothing!")
        return

    for _, sheet in all_exercise_sheets():
        with fileinput.input(sheet, inplace=True) as f:
            for line in f:
                if re.search(r"(\% )?\\solutiontrue", line):
                    print((r"\solutiontrue" if show else r"% \solutiontrue"))
                else:
                    print(line, end="")


@app.command()
def make_website():
    """
    Rebuild the entire Webpage from the tex files.

    Ignores all the .tex files with a Date in \\tutorialDate{...} later than now.
    """
    # copy over static files
    shutil.copytree(STATIC, WEB_ROOT, dirs_exist_ok=True)

    sheets = []
    review_exercises = []
    # make content
    for number, file in all_exercise_sheets():
        sheet = {
            "number": number,
            "tutorial_date": scrape_tutorial_date(file),
            "tex": str(file.relative_to(PROJECT)),
            "exercises": scrape_exercises(file),
        }
        html_target = file.with_suffix(".html").relative_to(PROJECT)
        if sheet["tutorial_date"] < datetime.now():
            make_html(file, source=PROJECT, destination=WEB_ROOT)
            sheet["html"] = str(html_target)
            review_exercises.extend(sheet["exercises"])
        else:
            WEB_ROOT.joinpath(html_target).unlink(missing_ok=True)

        sheets.append(sheet)

    typer.echo("Turn Exercise Review List into HTML")
    available = html_individual_exercises(review_exercises)
    available_full_path = [WEB_ROOT.joinpath(p).resolve() for p in available]
    for path in SINGLE_EXERCISE.rglob("*"):
        if path.is_file() and (path.resolve() not in available_full_path):
            path.unlink()

    with open(
        WEB_ROOT.joinpath("single_exercise", "available_for_review.json"), "w"
    ) as f:
        json.dump([str(path) for path in available], f)

    sheets.sort(key=lambda sheet: sheet["number"])
    index = html_jinja.get_template("index.html.jinja2").render(
        sheets={
            sheet["number"]: sheet.get("html") for sheet in sheets if "html" in sheet
        },
    )
    with open(WEB_ROOT.joinpath("index.html"), "w") as f:
        f.write(index)

    with open(PROJECT.joinpath("exercises.json"), "w") as f:
        json.dump({"sheets": sheets}, f, default=str, indent=4)


if __name__ == "__main__":
    # print(scrape_exercises("sheet_1.tex"))
    app()
